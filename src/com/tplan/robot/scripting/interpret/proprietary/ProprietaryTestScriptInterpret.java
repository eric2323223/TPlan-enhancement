/*
 * T-Plan Robot, automated testing tool based on remote desktop technologies.
 * Copyright (C) 2009  T-Plan Limited (http://www.t-plan.co.uk),
 * Tolvaddon Energy Park, Cornwall, TR14 0HX, United Kingdom
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package com.tplan.robot.scripting.interpret.proprietary;

import com.tplan.robot.scripting.commands.CommandEvent;
import com.tplan.robot.scripting.interpret.*;
import com.tplan.robot.ApplicationSupport;
import com.tplan.robot.scripting.*;
import com.tplan.robot.gui.editor.CustomStyledDocument;
import com.tplan.robot.plugin.DependencyMissingException;
import com.tplan.robot.plugin.PluginManager;
import com.tplan.robot.preferences.UserConfiguration;
import com.tplan.robot.remoteclient.RemoteDesktopClient;
import com.tplan.robot.scripting.commands.AbstractCommandHandler;
import com.tplan.robot.scripting.commands.CommandHandler;
import com.tplan.robot.scripting.commands.CommandListener;
import com.tplan.robot.scripting.wrappers.*;
import com.tplan.robot.util.DocumentUtils;
import com.tplan.robot.util.Utils;
import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.ConcurrentModificationException;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Vector;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.StyledDocument;
import static com.tplan.robot.scripting.ScriptingContext.*;

/**
 *
 * @author robert
 */
public class ProprietaryTestScriptInterpret extends AbstractTestScriptInterpret
        implements CommandListener {

    private CustomStyledDocument document = null;
    private int startOffset = -1,  endOffset = -1;
    private boolean destroyed = false;
    private List<String> nestedBlockInterprets;
    private final List<DocumentWrapper> actionWrapperList = new Vector();

    public void pushActionWrapper(DocumentWrapper wrapper) {
        synchronized (actionWrapperList) {
            actionWrapperList.add(wrapper);
        }
    }

    public List<DocumentWrapper> getPushedActionWrappers() {
        return new ArrayList(actionWrapperList);
    }

    public void destroy() {
        destroyed = true;
        document = null;
        getScriptManager().removeCommandListener(this);
        super.destroy();
    }

    public int getType() {
        return TYPE_PROPRIETARY;
    }

    public void setScriptManager(ScriptManager sm) {
        super.setScriptManager(sm);
        sm.addCommandListener(this);
    }

    public String[] getSupportedFileExtensions() {
        return null;
    }

    public boolean compile(ScriptingContext customContext) throws InterpretErrorException {
        if (nestedBlockInterprets == null) {
            nestedBlockInterprets = NestedBlockInterpretFactory.getInstance().getAvailableCodes();
        }
//        System.out.println("compile(), uri=" + getURI());
//        new Exception().printStackTrace();

        // TODO: CURTIME should be generated by the context
        // TODO: context initialization should be done by the context itself?
        ScriptWrapper w = new ScriptWrapper(getDocument(), getURI() == null ? null : new File(getURI().getPath()));
        compilationContext = customContext == null ? scriptManager.createDefaultContext() : customContext;
        initContext(compilationContext, true, w);

        run(compilationContext, scriptManager.getCommandHandlers(), false, true, false);

        // If the flag is on, fire an event which will be received by script editor which parses the errors and
        // highlights the invalid lines
        scriptManager.fireScriptEvent(new ScriptEvent(w, this, compilationContext, ScriptEvent.SCRIPT_COMPILATION_FINISHED));

        return false;
    }

    public ScriptingContext compileCustom(ScriptingContext ctx, Map cmdHandlers, boolean ignoreErrors, boolean fireEvents) {
        ScriptWrapper w = new ScriptWrapper(getDocument(), getURI() == null ? null : new File(getURI().getPath()));
        if (ctx == null) {
            ctx = scriptManager.createDefaultContext();
        }
        initContext(ctx, true, w);
        run(ctx, cmdHandlers, ignoreErrors, fireEvents, false);
        return ctx;
    }

    public int execute(ScriptingContext customContext) throws InterpretErrorException {
        // TODO: fix execution of the onpass/onfail commands
        // TODD: fix RFB event recording
        ScriptWrapper w;
        if (startOffset >= 0 && endOffset >= 0) {
            w = new ScriptWrapper(getDocument(), startOffset, endOffset, getURI() == null ? null : new File(getURI().getPath()));
        } else {
            w = new ScriptWrapper(getDocument(), getURI() == null ? null : new File(getURI().getPath()));
        }
        // Configure the wrapper for 'tolabel' and 'fromlabel' parameters
        configureWrapperForCLILabels(w);
        executionContext = customContext == null ? scriptManager.createDefaultContext() : customContext;
        initContext(executionContext, false, w);

        executing = true;
        run(executionContext, scriptManager.getCommandHandlers(), false, true, false);
        executing = false;
        return 0;
    }

    private ScriptingContext initContext(ScriptingContext ctx, boolean compile, DocumentWrapper w) {
        if (ctx == null) {
            ctx = scriptManager.createDefaultContext();
        }
        ctx.put(CONTEXT_MASTER_SCRIPT_WRAPPER, w);
        ctx.put(CONTEXT_CURRENT_SCRIPT_WRAPPER, w);
        ctx.put(CONTEXT_COMPILATION_FLAG, compile);
        ctx.put(CONTEXT_INTERPRET, this);
        if (getURI() != null) {
            ctx.setVariable(IMPLICIT_VARIABLE_FILE_NAME, new File(getURI().getPath()).getAbsolutePath());
            ctx.setVariable(IMPLICIT_VARIABLE_FILE_NAME_SHORT, new File(getURI().getPath()).getName());
        }
        w.setLocalVariables((Map) ctx.get(CONTEXT_VARIABLE_MAP));

        if (w != null && w.getScriptFile() != null) {
            String path;
            if (w.getScriptFile().getParentFile() != null) {
                path = w.getScriptFile().getParentFile().getAbsolutePath();
            } else {
                path = w.getScriptFile().getAbsolutePath();
                path = path.substring(0, path.lastIndexOf(File.separator));
            }
            ctx.setVariable(IMPLICIT_VARIABLE_SCRIPT_DIR, path);
        }
        return ctx;
    }

    public StyledDocument getDocument() {
        if (document == null) {
            document = new CustomStyledDocument(scriptManager, UserConfiguration.getInstance());
        }
        return document;
    }

    public String getDisplayName() {
        return MessageFormat.format(ApplicationSupport.getString("interpret.proprietary.pluginName"), ApplicationSupport.APPLICATION_NAME);
    }

    public String getDescription() {
        return MessageFormat.format(ApplicationSupport.getString("interpret.proprietary.pluginDesc"), ApplicationSupport.APPLICATION_NAME);
    }

    public String getUniqueId() {
        return "native_proprietary_language_interpret";
    }

    public boolean isPartialExecutionAllowed() {
        return true;
    }

    public void setSelection(int startOffset, int endOffset) throws IllegalStateException {
        if (startOffset < 0) {
            throw new IllegalArgumentException("Start offset must be >= 0.");
        }
        if (endOffset < startOffset) {
            throw new IllegalArgumentException("End offset must be >= start offset.");
        }
        if (endOffset > getDocument().getLength()) {
            throw new IllegalArgumentException("End offset is greater than source code length (endOffset=" + endOffset + ", documentLength=" + getDocument().getLength() + ").");
        }
        this.startOffset = startOffset;
        this.endOffset = endOffset;
    }

    public void resetSelection() throws IllegalStateException {
        startOffset = -1;
        endOffset = -1;
    }

//    private int exitCode = 0;
    private int delay = 0;
    private boolean rfbServerEventRecording = false;
    private boolean resetRfbServerEventRecording = false;
    private List rfbServerEvents = new ArrayList();
    private Element originalGotoElement = null;
    /**
     * The following array lists regexp patterns and values of dynamically created variables.
     * Any occurence of a variable will be replaced with it's default fullName provided that
     * no other fullName is available. The purpose of this code is to prevent the script validator
     * from reporting errors in code which uses these variables. See bug 13030.
     */
    private final static Object DEFAULT_VARS[][] = {
        {"_SEARCH_X", "-1"},
        {"_SEARCH_Y", "-1"},
        {"_SEARCH_X_[0-9]*", "-1"},
        {"_SEARCH_Y_[0-9]*", "-1"},
        {"_SEARCH_MATCH_COUNT", "0"},
        {"[0-9]*", "0"}
    };

    private void run(ScriptingContext ctx, Map cmdHandlers, boolean ignoreErrors, boolean fireEvents, boolean inProcedureDeclaration) {
        String line = "";

        final boolean validateOnly = ctx.isCompilationContext();
        final GenericWrapper scriptWrapper = (GenericWrapper) ctx.get(CONTEXT_CURRENT_SCRIPT_WRAPPER);
        final GenericWrapper globalScriptWrapper = (GenericWrapper) ctx.getMasterWrapper();
        final ResourceBundle res = ApplicationSupport.getResourceBundle();

        // Hidden feature - add a delay after each command. It is used to slow down
        // script executions for presentation/image capture purposes.
        if (System.getProperty("vncrobot.delay") != null) {
            try {
                delay = Integer.parseInt(System.getProperty("vncrobot.delay"));
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }

        try {
            final Map procedureHashTable = (Map) ctx.get(CONTEXT_PROCEDURE_MAP);
            final List validationMessages = (List) ctx.get(CONTEXT_COMPILATION_ERRORS);
            final Map vars = ctx.getVariables();

            if (globalScriptWrapper != null && globalScriptWrapper.equals(scriptWrapper)) {
                if (validateOnly) {
                    if (fireEvents) {
                        scriptManager.fireScriptEvent(new ScriptEvent(scriptWrapper, this, ctx, ScriptEvent.SCRIPT_COMPILATION_STARTED));
                    }
                } else {
                    executionContext.remove(SFLAG);
                    scriptManager.fireScriptEvent(new ScriptEvent(scriptWrapper, this, ctx, ScriptEvent.SCRIPT_EXECUTION_STARTED));
                }
            }

            final boolean debugMode = ctx.containsKey(ScriptingContext.CONTEXT_DEBUG_MODE_FLAG);

            Element currentElement = scriptWrapper.getStartElement();
            boolean isInProcedure = inProcedureDeclaration;
            GenericWrapper procedureWrapper = null;

            while ((currentElement != null || ctx.containsKey(CONTEXT_GOTO_TARGET_LABEL)) && (validateOnly || !isStop())) {
                ctx.put(CONTEXT_CURRENT_SCRIPT_WRAPPER, scriptWrapper);

                // GoTo label is set -> do not execute and continue until the label is found
                if (ctx.containsKey(CONTEXT_GOTO_TARGET_LABEL)) {
                    Map labels = (Map) ctx.get(CONTEXT_LABEL_MAP);
                    String label = (String) ctx.get(CONTEXT_GOTO_TARGET_LABEL);
                    if (labels != null && labels.containsKey(label)) {
                        ctx.remove(CONTEXT_GOTO_TARGET_LABEL);
                        vars.put(IMPLICIT_VARIABLE_EXIT_CODE, new Integer(0));
                        GenericWrapper wr = (GenericWrapper) labels.get(label);
                        runBlock(wr, ctx, isInProcedure);
                    } else {
                        currentElement = scriptWrapper.getNextElement(currentElement, validateOnly, ctx);
                    }

                    // End of document reached while looking for a label -> go to the original GoTo line,
                    // ignore the GoTo command and continue the execution
                    if (currentElement == null) {
                        currentElement = scriptWrapper.getNextElement(originalGotoElement, validateOnly, ctx);
                        ctx.remove(CONTEXT_GOTO_TARGET_LABEL);
                        vars.put(IMPLICIT_VARIABLE_EXIT_CODE, new Integer(1));
                    }
                }

                // The following condition breaks the execution cycle when end of a called procedure is reached
                if (scriptWrapper instanceof ProcedureWrapper && currentElement.equals(scriptWrapper.getSelectionEndElement())) {
                    return;
                }

                line = "";
                try {
                    int offs = currentElement.getStartOffset();
                    int length = currentElement.getEndOffset() - offs;
                    line = scriptWrapper.getDocument().getText(offs, length);
                    line = line.trim();
                } catch (BadLocationException e) {
                    e.printStackTrace();
                }

                // Ignore empty lines or comments starting with #
                if (line.length() < 1 || line.charAt(0) == '#' || line.startsWith("//")) {
                    if (debugMode && fireEvents) {
                        ScriptDebuggingEvent e = new ScriptDebuggingEvent(scriptWrapper, this, ctx, ScriptDebuggingEvent.SCRIPT_DEBUG_LINE_SKIPPED);
                        e.setCustomObject(line);
                        scriptManager.fireScriptEvent(e);
                    }
                    currentElement = scriptWrapper.getNextElement(currentElement, validateOnly, ctx);
                    continue;
                }

                // Lines starting with a colon ':' are labels of the goto command
                if (line.charAt(0) == ':') {
                    Map labels = (Map) ctx.get(CONTEXT_LABEL_MAP);
                    if (labels == null) {
                        labels = new HashMap();
                        ctx.put(CONTEXT_LABEL_MAP, labels);
                    }
                    String label = line.substring(1).trim();
                    boolean addLabel = true;
                    if (validateOnly) {
                        if ("".equals(label)) {
                            SyntaxErrorException e = new SyntaxErrorException(res.getString("scriptHandler.syntaxError.labelEmpty"));
                            addErrorMessage(e, scriptWrapper, currentElement, validationMessages);
                            addLabel = false;
                        } else if (labels.containsKey(label)) {
                            String message = res.getString("scriptHandler.syntaxError.duplicateLabel");
                            SyntaxErrorException e = new SyntaxErrorException(message);
                            addErrorMessage(e, scriptWrapper, currentElement, validationMessages);
                            addLabel = false;
                        }
                        if (isInProcedure) {
                            SyntaxErrorException e = new SyntaxErrorException(res.getString("scriptHandler.syntaxError.labelInProcedure"));
                            addErrorMessage(e, scriptWrapper, currentElement, validationMessages);
                            addLabel = false;
                        }
                        TestWrapper w = scriptWrapper;
                        while (w != null) {
                            if (scriptWrapper instanceof StructuredBlockWrapper) {
                                SyntaxErrorException e = new SyntaxErrorException(res.getString("scriptHandler.syntaxError.labelInBlock"));
                                addErrorMessage(e, scriptWrapper, currentElement, validationMessages);
                                addLabel = false;
                                break;
                            }
                            w = w.getParentWrapper();
                        }
                    }
                    if (addLabel) {
                        ScriptWrapper wr = new ScriptWrapper(scriptWrapper.getDocument(), 0, 0, scriptWrapper.getScriptFile());
                        wr.setLocalVariables(null);  // Disable local variables in this wrapper
                        wr.setSelectionStartElement(currentElement);
                        Document doc = wr.getDocument();
                        wr.setSelectionEndElement(doc.getDefaultRootElement().getElement(doc.getDefaultRootElement().getElementCount() - 1));
                        wr.setParentWrapper(scriptWrapper);
                        labels.put(label, wr);
                    }
                    currentElement = scriptWrapper.getNextElement(currentElement, validateOnly, ctx);
                    continue;
                }

                // GoTo label is set -> do not execute and continue until the label is found
                if (ctx.containsKey(CONTEXT_GOTO_TARGET_LABEL)) {
                    currentElement = scriptWrapper.getNextElement(currentElement, validateOnly, ctx);
                    continue;
                }

                final boolean isWithinSelection = scriptWrapper.isWithinSelection(currentElement, validateOnly, ctx);
                ctx.put(CONTEXT_SELECTED_DOCUMENT_ELEMENT, new Boolean(isWithinSelection));

//                if (!validateOnly) {
//                    System.out.println("ProprietaryTestScriptInterpret.run(): " + scriptWrapper.toString() + "#" + scriptWrapper.hashCode() + " (" +
//                            (scriptWrapper.getScriptFile() == null ? globalScriptWrapper.getScriptFile().getName() : scriptWrapper.getScriptFile().getName()) +
//                            ")" +
//                            ": executing line #" + (scriptWrapper.getElementIndex(currentElement) + 1) +
//                            ": '" + DocumentUtils.getElementText(currentElement) +
//                            "'\n   isWithinSelection = " + isWithinSelection + "\n   isInProcedure = " + isInProcedure);
//                }

                ctx.put(CONTEXT_CURRENT_DOCUMENT_ELEMENT, currentElement);

                if (!validateOnly && isWithinSelection && !isInProcedure) {
                    if (!(scriptWrapper instanceof IncludeWrapper)) { // && !(scriptWrapper instanceof ProcedureWrapper)) {
                        scriptManager.fireScriptEvent(new ScriptEvent(scriptWrapper, this, ctx, ScriptEvent.SCRIPT_EXECUTED_LINE_CHANGED));
                    }

                    ScriptEvent se = new ScriptEvent(scriptWrapper, this, ctx, ScriptEvent.SCRIPT_GOING_TO_RUN_LINE);
                    PauseRequestException ex = scriptManager.fireScriptEvent(se);
                    if (ex != null) {
                        // If any of the listeners throws an exception, it means that we
                        // are on a break point and we have to pause
                        if (scriptWrapper.canPause()) {
                            setPause(this, true, ex.getMessage());
                            String msg = ApplicationSupport.getResourceBundle().getString("scriptHandler.pausedAt");
                            msg = MessageFormat.format(msg, DocumentUtils.getElementText(currentElement));
                            scriptManager.fireScriptEvent(new ScriptEvent(scriptWrapper, this, ctx, msg));
                        }
                    }
                    if (delay > 0) {
                        Thread.sleep(delay);
                    }
                }

                // Ignore the pause flag if it is only a validation (bug #)
                if (!validateOnly) {
                    while (isPause() && (!validateOnly)) {
                        Thread.sleep(5);
                    }

                    if (isStop()) {
                        ctx.put(CONTEXT_STOP_REASON, "Manual stop");
                        break;
                    }
                }

                // If the RFB event recording is on, reset it after execution of one line.
                // Any command can switch this feature on to preserve RFB events for execution of a subsequent Waitfor command.
                if (!validateOnly && rfbServerEventRecording) {
                    if (resetRfbServerEventRecording) {
                        setRfbServerEventRecording(false);
                        resetRfbServerEventRecording = false;
                    } else {
                        resetRfbServerEventRecording = true;
                    }
                }

                // Cut the very first word
                int i = line.indexOf(' ');
                String command = i >= 0 ? line.substring(0, i) : line;

                command = command.toUpperCase();

                // Process end of a structured block which must start with a '}'
                if (command.startsWith("}")) {
                    boolean isJustEnd = line.equals("}");

                    if (scriptWrapper instanceof ProcedureWrapper) {
                        // Remove all number parameters
                        ((ProcedureWrapper) scriptWrapper).popArguments();

                    } else if (scriptWrapper instanceof StructuredBlockWrapper) {
                        // StructuredBlockWrapper instances represent 'else', 'if' and 'for' blocks.
                        StructuredBlockWrapper sw = (StructuredBlockWrapper) scriptWrapper;
                        boolean shoudReturn = true;
                        try {
                            shoudReturn = sw.shouldExitWrapperOnThisElement(currentElement, line, ctx, validateOnly, isWithinSelection);
                        } catch (Exception ex) {
                            // This method only throws Exceptions if the line code has invalid syntax
                            addErrorMessage(new SyntaxErrorException(ex.getMessage()), scriptWrapper, currentElement, validationMessages);
                            if (!validateOnly) { // Executing?
                                ex.printStackTrace();
                            }
                        }

                        if (shoudReturn) {
//                            firePropertyChange("variablesChanged", null, this);
                            if (debugMode && fireEvents) {
                                scriptManager.fireScriptEvent(new ScriptDebuggingEvent(scriptWrapper, this, ctx, ScriptDebuggingEvent.SCRIPT_DEBUG_STRUCTURE_END_REACHED));
                            }
                            return;
                        }

                    // If we are in procedure definition, reset the isInProcedure flag and set the pointer to
                    // procedure end in the script wrapper.
                    } else if (isInProcedure) {
                        // No other string allowed after "}" if it is a procedure
                        if (!isJustEnd) {
                            addErrorMessage(new SyntaxErrorException(res.getString("scriptHandler.syntaxError.unknownCodeAfterBrace")), scriptWrapper, currentElement, validationMessages);
                        }
//                        System.out.println("   setting isInProcedure to false");
                        isInProcedure = false;
                        ctx.remove(CONTEXT_PROCEDURE_DECLARATION_FLAG);
                        procedureWrapper.setSelectionEndElement(currentElement);
                        procedureWrapper = null;
                        if (debugMode && fireEvents) {
                            scriptManager.fireScriptEvent(new ScriptDebuggingEvent(scriptWrapper, this, ctx, ScriptDebuggingEvent.SCRIPT_DEBUG_PROCEDURE_DEFINITION_END_REACHED));
                        }
                    } else {
                        addErrorMessage(new SyntaxErrorException(res.getString("scriptHandler.syntaxError.unterminatedBlock")), scriptWrapper, currentElement, validationMessages);
                    }
                    // Get the next element
                    currentElement = scriptWrapper.getNextElement(currentElement, validateOnly, ctx);
                    continue;
                }


                CommandHandler c = (CommandHandler) cmdHandlers.get(command);
                if (c != null) {
                    try {
                        if ((isWithinSelection || c.isGlobalPrerequisity(line))) {
                            if (isInProcedure || validateOnly) {
                                if (!isInProcedure) {
                                    String modifiedLine = applyVariablesToCommand(line, ctx);
                                    List args = new ArrayList();
                                    Map values = ctx.getParser().parseParameters(modifiedLine, args);
                                    c.validate(args, values, null, ctx);
                                    if (debugMode && fireEvents) {
                                        ScriptEvent e = new ScriptDebuggingEvent(procedureWrapper == null ? scriptManager : procedureWrapper, this, ctx, ScriptDebuggingEvent.SCRIPT_DEBUG_VALIDATING_LINE);
                                        e.setCustomObject(line);
                                        scriptManager.fireScriptEvent(e);
                                    }
                                    vars.put(IMPLICIT_VARIABLE_EXIT_CODE, new Integer(0));
                                } else {
                                    if (debugMode && isInProcedure && fireEvents) {
                                        ScriptEvent e = new ScriptDebuggingEvent(scriptWrapper, this, ctx, ScriptDebuggingEvent.SCRIPT_DEBUG_COMMAND_IN_PROCEDURE_REACHED);
                                        e.setCustomObject(line);
                                        scriptManager.fireScriptEvent(e);
                                    }
                                }
                            // Do nothing if we are in a procedure
                            } else if (scriptWrapper.isExecutionAllowed()) {
                                ctx.put(CONTEXT_LAST_EXECUTED_DOCUMENT_ELEMENT, currentElement);
                                RemoteDesktopClient client = ctx.getClient();
                                if (c.canRunWithoutConnection() || (client != null && client.isConnected())) {// client == null || client.isConnected() || c.canRunWithoutConnection()) {
                                    String modifiedLine = applyVariablesToCommand(line, ctx);
                                    List args = new ArrayList();
                                    Map values = ctx.getParser().parseParameters(modifiedLine, args);
                                    int retVal = c.execute(args, values, ctx);
                                    vars.put(IMPLICIT_VARIABLE_EXIT_CODE, new Integer(retVal));
                                } else {
                                    System.out.println(MessageFormat.format(res.getString("scriptHandler.syntaxError.commandRequiresConnection"), c.getCommandNames()[0].toUpperCase()));
                                    setStop(this, isStop(), false, null);
                                    ctx.getVariables().put(IMPLICIT_VARIABLE_EXIT_CODE, 1);
                                    break;
                                }
                            }
                        }
                        if (validateOnly && !isWithinSelection) {
                            if (!isInProcedure) {   // Do not validate the procedure contents
                                String modifiedLine = applyVariablesToCommand(line, ctx);
                                List args = new ArrayList();
                                Map values = ctx.getParser().parseParameters(modifiedLine, args);
                                c.validate(args, values, null, ctx);
                                if (debugMode && fireEvents) {
                                    ScriptEvent e = new ScriptDebuggingEvent(scriptWrapper, this, ctx, ScriptDebuggingEvent.SCRIPT_DEBUG_VALIDATING_LINE);
                                    e.setCustomObject(line);
                                    scriptManager.fireScriptEvent(e);
                                }
                            }
                        }
                    } catch (SyntaxErrorException e) {
                        if (scriptWrapper instanceof ProcedureWrapper) {
                            addErrorMessage(e, scriptWrapper.getParentWrapper(), ((ProcedureWrapper) scriptWrapper).getParentElement(), validationMessages);
                        } else {
                            addErrorMessage(e, scriptWrapper, currentElement, validationMessages);
                        }
                    } catch (Exception ex) {
                        String s = res.getString("scriptHandler.syntaxError.internalError");
                        System.out.println(MessageFormat.format(s, (scriptWrapper.getElementIndex(currentElement) + 1), scriptWrapper.getScriptFile(), line));
                        ex.printStackTrace();
                    }


                } else if (procedureHashTable.containsKey(command)) {
                    if (isWithinSelection && !(scriptWrapper instanceof IncludeWrapper) && !isInProcedure) {
                        ProcedureWrapper wrapper = (ProcedureWrapper) procedureHashTable.get(command);
                        if (!validateOnly) {
//                            firePropertyChange("procedureStarted", wrapper.getEditor(), command);
                            ScriptEvent evt = new ScriptEvent(scriptWrapper, this, ctx, ScriptEvent.SCRIPT_PROCEDURE_STARTED);
                            evt.setCustomObject(currentElement);
                            scriptManager.fireScriptEvent(evt);
                        }
                        String modifiedLine = applyVariablesToCommand(line, ctx);
                        Map<String, String> args = new HashMap();
                        addProcedureArguments(ctx, args, modifiedLine, wrapper);
                        wrapper.pushArguments(args);
                        wrapper.setParentElement(currentElement);
                        if (debugMode && fireEvents) {
                            ScriptEvent e = new ScriptDebuggingEvent(wrapper, this, ctx, ScriptDebuggingEvent.SCRIPT_DEBUG_PROCEDURE_CALL_REACHED);
                            e.setCustomObject(wrapper);
                            scriptManager.fireScriptEvent(e);
                        }
                        runBlock(wrapper, ctx, isInProcedure);
                        if (!validateOnly) {
                            ctx.put(CONTEXT_LAST_EXECUTED_DOCUMENT_ELEMENT, currentElement);
                            ScriptEvent evt = new ScriptEvent(scriptWrapper, this, ctx, ScriptEvent.SCRIPT_PROCEDURE_FINISHED);
                            evt.setCustomObject(currentElement);
                            scriptManager.fireScriptEvent(evt);
                        } else if (debugMode && fireEvents) {
                            ScriptEvent e = new ScriptDebuggingEvent(wrapper, this, ctx, ScriptDebuggingEvent.SCRIPT_DEBUG_PROCEDURE_CALL_ENDED);
                            e.setCustomObject(line);
                            scriptManager.fireScriptEvent(e);
                        }
                    }

                } else if ("PROCEDURE".equals(command)) {

                    // Define a new procedure wrapper only if we are in a procedure definition.
                    // This will create a new script wrapper initialized with the beginning and end of the procedure.
                    // The wrapper will be placed into a hashtable where procedure name is a key.
                    // Any procedure calls will be then matched against the hashtable content and replayed
                    // according to the script wrapper info.
                    if (!(scriptWrapper instanceof ProcedureWrapper)) {
                        // Create a new script wrapper and set the start line to the first procedure command
                        try {
                            validateProcedure(ctx, line, procedureHashTable);
                            String tokens[] = line.trim().split("\\s");
                            String procName = tokens[1];
                            procedureWrapper = new ProcedureWrapper(scriptWrapper, scriptWrapper.getDocument(), procName, true);
                            procedureWrapper.setSelectionStartElement(currentElement);
                            procedureWrapper.setScriptFile(scriptWrapper.getScriptFile());
                            procedureHashTable.put(procName.toUpperCase(), procedureWrapper);
                            isInProcedure = true;
                            ctx.put(CONTEXT_PROCEDURE_DECLARATION_FLAG, new Boolean(true));
                            if (debugMode && fireEvents) {
                                ScriptEvent e = new ScriptDebuggingEvent(procedureWrapper, this, ctx, ScriptDebuggingEvent.SCRIPT_DEBUG_PROCEDURE_WRAPPER_CREATED);
                                e.setCustomObject(procedureWrapper);
                                scriptManager.fireScriptEvent(e);
                            }
                        } catch (SyntaxErrorException e) {
                            addErrorMessage(e, scriptWrapper, currentElement, validationMessages);
                        }
                    }

                } else if ("IF".equals(command) || "FOR".equals(command)) {
                    // Process the command only if it is within selection, skip it otherwise
                    try {
                        StructuredBlockWrapper wr = null;
                        if ("FOR".equals(command)) {
                            wr = new ForWrapper(scriptWrapper.getDocument(), scriptWrapper, currentElement, ctx, validateOnly);
                        } else if ("IF".equals(command)) {
                            wr = new IfWrapper(scriptWrapper.getDocument(), scriptWrapper, currentElement, ctx, validateOnly);
                        }
                        if (debugMode && fireEvents) {
                            scriptManager.fireScriptEvent(new ScriptDebuggingEvent(wr, this, ctx, ScriptDebuggingEvent.SCRIPT_DEBUG_STRUCTURE_WRAPPER_CREATED));
                        }
                        runBlock(wr, ctx, isInProcedure);
                        if (fireEvents) {
                            scriptManager.fireScriptEvent(new ScriptEvent(wr, this, ctx, ScriptEvent.SCRIPT_VARIABLES_UPDATED));
                        }
                        if (wr.getSelectionEndElement() != null) {
                            currentElement = wr.getSelectionEndElement();
                        }
                    } catch (Exception ex) {
                        addErrorMessage(new SyntaxErrorException(ex.getMessage()),
                                scriptWrapper, currentElement, validationMessages);
                    }

                } else if (nestedBlockInterprets != null && Utils.containsIgnoreCase(nestedBlockInterprets, command)) {
                    try {
                        NestedBlockInterpret wr = NestedBlockInterpretFactory.getInstance().getInterpret(command.toLowerCase());
                        wr.init(scriptWrapper.getDocument(), scriptWrapper, currentElement, ctx, validateOnly || !isWithinSelection);
                        if (debugMode && fireEvents) {
                            scriptManager.fireScriptEvent(new ScriptDebuggingEvent(wr, this, ctx, ScriptDebuggingEvent.SCRIPT_DEBUG_NESTED_BLOCK_CREATED));
                        }
                        if (validateOnly && fireEvents) {
                            scriptManager.fireScriptEvent(new ScriptEvent(wr, this, ctx, ScriptEvent.SCRIPT_NESTED_INTERPRET_CREATED));
                        }
                        currentElement = wr.getEndElement();
                    } catch (SyntaxErrorException ex) {
                        addErrorMessage(ex, scriptWrapper, currentElement, validationMessages);
                    }

                } else if ("BREAK".equalsIgnoreCase(command)) {
                    if (!handleBreak(scriptWrapper, validateOnly, isWithinSelection)) {
                        SyntaxErrorException e = new SyntaxErrorException(res.getString("scriptHandler.syntaxError.misplacedBreak"));
                        addErrorMessage(e, scriptWrapper, currentElement, validationMessages);
                    }
                } else if (!ignoreErrors) {
                    String s = res.getString("scriptHandler.syntaxError.unsupportedCommand");
                    SyntaxErrorException e = new SyntaxErrorException(MessageFormat.format(s, line));
                    addErrorMessage(e, scriptWrapper, currentElement, validationMessages);
                }

                // Get the next element
                currentElement = scriptWrapper.getNextElement(currentElement, validateOnly, ctx);

                synchronized (actionWrapperList) {
                    if (!isStop() && actionWrapperList.size() > 0) {
                        List<DocumentWrapper> l = new ArrayList(actionWrapperList);
                        actionWrapperList.clear();
                        do {
                            DocumentWrapper wr = l.remove(0);
                            runBlock(wr, ctx, false);
                        } while (l.size() > 0);
                    }
                }

                // Ignore the pause flag if it is only a validation (bug #)
                if (!validateOnly) {
                    while (isPause()) {
                        Thread.sleep(5);
                    }
                    if (delay > 0) {
                        Thread.sleep(delay);
                    }
                }
            }

            if (isInProcedure) {
                String s = res.getString("scriptHandler.syntaxError.unterminatedProcedure");
                SyntaxErrorException e = new SyntaxErrorException(MessageFormat.format(s, ((ProcedureWrapper) procedureWrapper).getProcedureName()));
                addErrorMessage(e, scriptWrapper, procedureWrapper.getSelectionStartElement(), validationMessages);
            }

        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }

        // Fire an action event to notify listeners that the script replay has finished.
        // Length of the run in ms is sent in the action event using the 'when' field.
        if (scriptWrapper instanceof ScriptWrapper && !(scriptWrapper instanceof StructuredBlockWrapper)) {
            if (!validateOnly) {
                executing = false;
                executionContext.remove(PFLAG);
            }
            if (isStop() && !validateOnly) {
                if (manualStop) {
                    if (manualStopJustification != null) {
                        ctx.put(CONTEXT_STOP_REASON, manualStopJustification);
                    }
                    scriptManager.fireScriptEvent(new ScriptEvent(scriptWrapper, this, ctx, ScriptEvent.SCRIPT_EXECUTION_STOPPED));
                }
            }

            if (validateOnly) {
                if (!ignoreErrors && fireEvents) {
                    scriptManager.fireScriptEvent(new ScriptEvent(scriptWrapper, this, ctx, ScriptEvent.SCRIPT_ERRORS_AVAILABLE));
                    scriptManager.fireScriptEvent(new ScriptEvent(scriptWrapper, this, ctx, ScriptEvent.SCRIPT_COMPILATION_FINISHED));
                }
            } else {
                Object o = ctx.get(ScriptingContext.CONTEXT_INTERPRET);
                scriptManager.fireScriptEvent(new ScriptEvent(scriptWrapper == null ? scriptManager : scriptWrapper, this, ctx, ScriptEvent.SCRIPT_EXECUTION_FINISHED));
            }
        }
    }

    public void runBlock(DocumentWrapper wrapper, ScriptingContext repository) {
        runBlock(wrapper, repository, false);
    }

    public void runBlock(DocumentWrapper wrapper, ScriptingContext repository, boolean inProcedureDeclaration) {
        GenericWrapper originalWrapper = (GenericWrapper) repository.get(CONTEXT_CURRENT_SCRIPT_WRAPPER);
        if (originalWrapper == null) {
            originalWrapper = (GenericWrapper) repository.get(CONTEXT_MASTER_SCRIPT_WRAPPER);
        }
        wrapper.setParentWrapper(originalWrapper);
        repository.put(CONTEXT_CURRENT_SCRIPT_WRAPPER, wrapper);
        run(repository, scriptManager.getCommandHandlers(), false, true, inProcedureDeclaration);
        repository.put(CONTEXT_CURRENT_SCRIPT_WRAPPER, originalWrapper);
    }

    private boolean handleBreak(TestWrapper scriptWrapper, boolean validateOnly, boolean isWithinSelection) {
        ForWrapper wr = null;

        // Go through the chain of wrappers and look for a 'for' one
        while (scriptWrapper.getParentWrapper() != null) {
            if (scriptWrapper instanceof ForWrapper) {
                wr = (ForWrapper) scriptWrapper;
                break;
            }
            scriptWrapper = scriptWrapper.getParentWrapper();
        }

        // If we are inside a 'for' loop, break it
        if (wr != null && !validateOnly && isWithinSelection) {
            wr.breakFor();
        }
        return wr != null;
    }

    private void addErrorMessage(SyntaxErrorException e, DocumentWrapper wrapper, Element element, List validationMessages) {
        if (wrapper instanceof TextBlockWrapper) {
            TextBlockWrapper tw = (TextBlockWrapper) wrapper;
            e.setElement(tw.getMasterElement());
            e.setLineIndex(tw.getParentWrapper().getElementIndex(element) + 1);
        } else {
            e.setElement(element);
            e.setLineIndex(wrapper.getElementIndex(element) + 1);
        }
        e.setScriptFile(wrapper.getScriptFile());
        validationMessages.add(e);
    }

    public void setRfbServerEventRecording(boolean rfbServerEventRecording) {
        this.rfbServerEventRecording = rfbServerEventRecording;
        rfbServerEvents.clear();
        resetRfbServerEventRecording = false;
    }

    public String applyVariablesToCommand(String command, ScriptingContext repository) {

        // First get the variable hash table from the execution context. Create an empty one if it doesn't exist.
        Map variables = new Hashtable();
        Utils.putAll(variables, repository.getVariables());

        // Apply variables passed via CLI if there are any
        Map cliVars = repository.getCommandLineVariables();
        if (cliVars != null) {
            variables.putAll(cliVars);
        }

        // Apply the procedure arguments
        TestWrapper wrapper = (TestWrapper) repository.get(CONTEXT_CURRENT_SCRIPT_WRAPPER);

        // Find out if ve are in a procedure or any parent wrapper is procedure
        boolean inProcedure = false;
        while (wrapper != null) {
            if (wrapper instanceof ProcedureWrapper) {
                inProcedure = true;
                break;
            }
            wrapper = wrapper.getParentWrapper();
        }

        if (inProcedure) {
            Map args = ((ProcedureWrapper) wrapper).getArguments();
            if (args != null) {
                variables.putAll(args);
            }
        }

        UserConfiguration cfg = repository.getConfiguration();
        boolean oldVariableReplacement = cfg.getBoolean("scripting.replaceVariablesCompatMode").booleanValue();

        DocumentWrapper wr = (DocumentWrapper) repository.get(CONTEXT_CURRENT_SCRIPT_WRAPPER);
        int index, endIndex, position = 0;
        String name, val;
        Object o;

//        System.out.println("## Starting to apply variables in command:\n  '" + command + "'");
        boolean disableNestedVariables = cfg.getBoolean("scripting.disableNestedVariables").booleanValue();
//        System.out.println("Disable nested variables = "+disableNestedVariables);

        // NEW CODE SUPPORTING NESTED VARIABLES ---------------------------------------------------------
        if (!disableNestedVariables) {
            int start = 0;
            boolean change;
            String pre,
                    post;
            do {
                change = false;
                position =
                        0;
                while ((position = command.indexOf('}', position)) >= 0) {

                    // Find the matching left curly brace
                    start = command.substring(0, position).lastIndexOf('{');

                    // If there's a matching left curly brace, get the var name and try to get its fullName
                    if (start >= 0 && command.length() > start + 1) {
                        name = command.substring(start + 1, position);
                        val = getApplicableValue(name, cliVars, wr, variables, repository);

                        // If fullName is null, leave it as it is.
                        // Otherwise replace the {name} statement with the fullName.

                        // Bug fix in 2.0.3 - when the variable is not defined, test if
                        // the value is equal to the variable name plus the curly braces.
                        // Otherwise the code ends in an infinite loop and gets stuck
                        // because the command keeps containing curly braces which
                        // keeps the while loop alive.
                        if (val != null && !val.equals("{" + name + "}")) {
                            // Bug 2951672 fix in 2.0.3OS/2.1EE
                            val = Utils.escapeUnescapedDoubleQuotes(val);
                            command = replace(repository, command, name, start, position, val);
                            position = 0;   // Set the search position to beginning because we changed the command string
                            change = true;
                        } else {
                            position = position + 1;
                        }
                    } else {
                        position = position + 1;
                    }
                }
            } while (change);


        // OLD CODE -------------------------------------------------------------------------------------
        } else {
            while (position < command.length() && (index = command.indexOf('{', position)) > -1) {
                endIndex = command.indexOf('}', index);
                if (endIndex >= 0) {

                    // Parse variable name (word enclosed by {})
                    name = command.substring(index + 1, endIndex);

                    val = getApplicableValue(name, cliVars, wr, variables, repository);
                    // This means that we found a fullName
                    if (val != null) {

                        // If we are in compatibility mode, use regular expressions to replace
                        if (oldVariableReplacement) {
                            command = command.replaceFirst("\\{" + name + "\\}", val);
                        } else {
//                            command = command.substring(0, index) + val + command.substring(endIndex + 1);
                            command = replace(repository, command, name, index, endIndex, val);
                        }

                        position = index + val.length();
//                    System.out.println("-- replaced variable " + name + "=" + val + "\n  result: " + command +
//                            "\n  new position=" + position + " (substring: '" + command.substring(position) + "')");

                    } else {  // No fullName was found -> move the string pointer after the '{' char
                        position = index + 1;
                    }

                } else {
                    break;  // No matching '}' was found -> there are no more variables, break the cycle
                }

            }
        }
        return command;
    }

    public String getApplicableValue(String name, Map cliVars, TestWrapper wr, Map variables, ScriptingContext ctx) {

        Object o = getScriptManager().getDynamicVariableValue(name, cliVars, variables, wr, ctx);

        if (o == null) {
            // CLI variables override everything
            o = cliVars.get(name);

            // If there's no overriden fullName from CLI, try to load a variable through the wrapper method
            // getVariable(). If the result is null, look in the global variable context
            if (o == null) {
                if (wr != null && wr instanceof DocumentWrapper) {
                    o = ((DocumentWrapper) wr).getVariable(name);
                }

                if (o == null) {
                    o = variables.get(name);
                }

// Bugfix 13030
                if (o == null) {
                    for (int i = 0; i <
                            DEFAULT_VARS.length; i++) {
                        if (name.matches(DEFAULT_VARS[i][0].toString())) {
                            o = DEFAULT_VARS[i][1];
                        }

                    }
                }
            }
        }
        return o == null ? null : getDisplayValue(o);
    }

    /**
     * Format an object for output. This method makes sure that if the object is an integer number, it gets
     * displayed without the floating point part. The method returns for any other object result
     * of the Object.toString() method.
     *
     * @param o an object.
     * @return formatted output.
     */
    private String getDisplayValue(Object o) {
        if (o instanceof Number) {
            Number n = (Number) o;
            if (n.intValue() == n.doubleValue()) {
                return Integer.toString(n.intValue());
            }

        }
        return o == null ? null : o.toString();
    }

    public String replace(ScriptingContext ctx, String text, String variableName, int startOffset, int endOffset, String value) {
        return text.substring(0, startOffset) + value + text.substring(endOffset + 1);
    }

    private void addProcedureArguments(ScriptingContext ctx, Map<String, String> vars, String line, DocumentWrapper wr) {
        List v = new ArrayList();
        Map t = ctx.getParser().parse(line, v);
        String key, value;
        int i = 0;
        for (; i < v.size(); i++) {
            key = (String) v.get(i);
            value = t.containsKey(key) ? key + "=" + t.get(key) : key;
            value = value == null ? "" : value;
            vars.put(i + "", value);
        }
        vars.put(IMPLICIT_VARIABLE_PROCEDURE_ARGUMENT_COUNT, "" + (i - 1));
    }

    private void validateProcedure(ScriptingContext ctx, String line, Map procedureMap) throws SyntaxErrorException {
        List v = new ArrayList();
        ResourceBundle res = ApplicationSupport.getResourceBundle();
        try {
            ctx.getParser().parse(line, v);
            if (v.size() != 3 || !v.get(2).toString().trim().equals("{")) {
                throw new SyntaxErrorException(res.getString("scriptHandler.syntaxError.procedureHeaderError"));
            }

            String name = (String) v.get(1);
            if (procedureMap.containsKey(v.get(1))) {
                ProcedureWrapper pw = (ProcedureWrapper) procedureMap.get(name);
                String s = res.getString("scriptHandler.syntaxError.procExists");
                throw new SyntaxErrorException(MessageFormat.format(s, name, pw.getScriptFile(), pw.getElementIndex(pw.getStartElement())));
            }

            // Validate if the procedure name conflicts with a reserved name
            name = name.toUpperCase();
            if (scriptManager.getCommandHandlers().containsKey(name)) {
                throw new SyntaxErrorException(res.getString("scriptHandler.syntaxError.procNameReserved"));
            }
            if (name.equals("IF") || name.equals("PROCEDURE") || name.equals("FOR")) {
                String s = res.getString("scriptHandler.syntaxError.procNameIsKeyword");
                throw new SyntaxErrorException(MessageFormat.format(s, name));
            }
            if (name.charAt(0) == ':') {
                throw new SyntaxErrorException(res.getString("scriptHandler.syntaxError.procNameStartsWithColon"));
            }
        } catch (Exception ex) {
            String s = res.getString("scriptHandler.syntaxError.procInternalError");
            throw new SyntaxErrorException(MessageFormat.format(s, ex.getMessage()));
        }
    }

    private void configureWrapperForCLILabels(GenericWrapper w) {
        String toLabel = (String) scriptManager.getScriptingParams().get("tolabel");
        String fromLabel = (String) scriptManager.getScriptingParams().get("fromlabel");

        Element toElem = getElement(w, ":" + toLabel + "$");
        Element fromElem = getElement(w, ":" + fromLabel + "$");

        if (toElem != null || fromElem != null) {
            Element e = w.getDocument().getDefaultRootElement();
            fromElem = fromElem == null ? e.getElement(0) : fromElem;
            toElem = toElem == null ? e.getElement(e.getElementCount() - 1) : toElem;
            w.setSelectionStartElement(fromElem);
            w.setSelectionEndElement(toElem);
            w.setSelectionMode(true);
        }
    }

    private Element getElement(GenericWrapper w, String text) {
        List v = DocumentUtils.findElements(w.getDocument(), text);
        if (v.size() > 0) {
            if (v.size() > 1) {
                String s = ApplicationSupport.getString("scriptHandler.syntaxError.duplicateLabelWarning");
                System.out.println(MessageFormat.format(s, text));
            }

            return (Element) v.get(0);
        }
        return null;
    }

    public File resolveScriptFile(String fileName, ScriptingContext context) throws IOException {
        final GenericWrapper currentWrapper = (GenericWrapper) context.get(CONTEXT_CURRENT_SCRIPT_WRAPPER);
        File f = new File(fileName);

        // Resolve relative file
        if (!f.isAbsolute()) {
            String parentFile;
            if (currentWrapper.getScriptFile() == null) {  // An untitled editor -> look in the user dir
                parentFile = System.getProperty("user.home");
            } else {  // Look in the folder of this script
                parentFile = currentWrapper.getScriptFile().getParent();
            }
            f = new File(parentFile, fileName);
        }
        // Bug
        f = f.getCanonicalFile();
        return f;
    }

    private void runCommand(List params, Map values, ScriptingContext context, boolean isRunMode) {
        final GenericWrapper currentWrapper = (GenericWrapper) context.get(CONTEXT_CURRENT_SCRIPT_WRAPPER);
        final List validationMessages = (List) context.get(CONTEXT_COMPILATION_ERRORS);
        final Element currentElement = (Element) context.get(CONTEXT_CURRENT_DOCUMENT_ELEMENT);
        final boolean validateOnly = context.isCompilationContext();
        String command = isRunMode ? "Run" : "Include";
        ResourceBundle res = ApplicationSupport.getResourceBundle();

//        System.out.println("--- runCommand(), validateOnly=" + validateOnly + ", interpret "+this.hashCode()+" uri=" + getURI());

        // Find out if the Run/Include message is applicable to this interpret
        ScriptingContext c = validateOnly ? getCompilationContext() : getExecutionContext();
        if (destroyed || !context.equals(c)) {
            return;
        }

        try {

            // Bugfix - Run commands called from Include wrapper should not execute
            if (isRunMode && !validateOnly && currentWrapper instanceof IncludeWrapper) {
                isRunMode = false; // Change to Include mode
            }

            // The command must contain exactly one parameter (file name)
            if (params.size() != 1) {
                throw new SyntaxErrorException(res.getString("scriptHandler.syntaxError.runOrIncludeError"));
            }

            // Determine the file path
            String fileName = (String) params.get(0);
            File f = resolveScriptFile(fileName, context);

            URI uri = f.toURI();
            TestScriptInterpret interpret = null;

//            System.out.println("runCommand(), file " + getURI() + " includes or runs file " + uri + "\n  cache content: " + interpretCache);

            // First find out if the file is already open in one of the editors.
            List<TestScriptInterpret> lt = context.getScriptManager().getActiveTestScripts();
            for (TestScriptInterpret t : lt) {
//                System.out.println("  processing interpret of " + t.getURI());
                if (uri.equals(t.getURI())) {
//                    System.out.println("    matching URIs: found interpret");
                    interpret = t;

                    // TODO: do not compile if there are no script code changes.
                    // It however requires to move the "changed" flag from the
                    // GUI editor component either to CustomStyledDocument
                    // or to the interpret class.
                    interpret.compile(null);
                    break;
                }
            }

            // File is not open in any editor -> create a new script interpret
            if (interpret == null) {
                interpret = TestScriptInterpretFactory.getInstance().createByExtension(uri);
                interpret.setScriptManager(context.getScriptManager());
                try {
                    interpret.setURI(uri, true);
                } catch (IOException e) {
                    String s = res.getString("scriptHandler.syntaxError.runOrIncludeFileNotFound");
                    addErrorMessage(new SyntaxErrorException(MessageFormat.format(s, f.getAbsolutePath())),
                            currentWrapper, currentElement, validationMessages);
                    scriptManager.fireScriptEvent(new ScriptEvent(currentWrapper, this, context, ScriptEvent.SCRIPT_INCLUDE_FAILED));
                    interpret.destroy();
                    return;
                }
                // Bug 2923342 fix in 2.0.1 - compile the new interpret
                // to get it into script manager's list of active scripts
                interpret.compile(null);
            }

            // Recursive script error - attempt to Include or Run the same script
            if (isRunMode && uri.equals(context.getInterpret().getURI()) || interpret.equals(context.getInterpret())) {
                SyntaxErrorException e = new SyntaxErrorException(res.getString("scriptHandler.syntaxError.recursiveScript"));
                addErrorMessage(e, currentWrapper, currentElement, validationMessages);
            }

            // If we are in execution mode, fire an event to make sure the GUI
            // displays the file in a new editor
            if (!validateOnly) {
                ScriptEvent evt = new ScriptEvent(currentWrapper, this, context, ScriptEvent.SCRIPT_EXECUTING_INCLUDE);
                evt.setCustomObject(f);
                scriptManager.fireScriptEvent(evt);
                context.put(CONTEXT_LAST_EXECUTED_DOCUMENT_ELEMENT, currentElement);
            }

            GenericWrapper wrapper;

            // Bug fix 13042 - if we are running a 'Run' command and it is not selected in the editor,
            // execute 'Include' instead.
            // The original code was just 'if (isRunMode) {'
            final boolean isWithinSelection = ((Boolean) context.get(CONTEXT_SELECTED_DOCUMENT_ELEMENT)).booleanValue();

            if (isRunMode && isWithinSelection) {
                wrapper = new RunWrapper(interpret.getDocument(), -1, -1, false /*globalScriptWrapper.isSelectionMode()*/);
            } else {
                wrapper = new IncludeWrapper(interpret.getDocument(), -1, -1, false /*globalScriptWrapper.isSelectionMode()*/);
            }
            wrapper.setScriptFile(f);
            wrapper.setParentWrapper(currentWrapper);
            runBlock(wrapper, context, false);

            // Bug fix for 2.0.6/2.1.1: Restore the current document element
            // to make the editor handle Run/Include syntax errors correctly
            context.put(ScriptingContext.CONTEXT_CURRENT_DOCUMENT_ELEMENT, currentElement);
        } catch (Exception e) {
            String s = res.getString("scriptHandler.syntaxError.runOrIncludeFormatError");
            addErrorMessage(new SyntaxErrorException(MessageFormat.format(s, command)),
                    currentWrapper, currentElement, validationMessages);
            scriptManager.fireScriptEvent(new ScriptEvent(currentWrapper, this, context, ScriptEvent.SCRIPT_INCLUDE_FAILED));
        }
    }

    public void commandEvent(CommandEvent evt) {
        if (evt.getSource() instanceof CommandHandler) {
            String name = evt.getActionCode();
            if ("run".equals(name)) {
                Object o[] = (Object[])evt.getCustomObject();
                runCommand((List) o[0], (Map)o[1], evt.getContext(), true);
            } else if ("include".equals(name)) {
                runCommand((List) evt.getCustomObject(), null, evt.getContext(), false);
            }
        }
    }

    public CommandHandler getCommandHandlerForElement(Element e) {
        String line = "";
        try {
            line = e.getDocument().getText(e.getStartOffset(), e.getEndOffset() - e.getStartOffset());
        } catch (BadLocationException ex) {
            ex.printStackTrace();
            return null;
        }

        String tokens[] = line.trim().split("\\s");
        if (tokens != null && tokens.length > 0) {
            String command = tokens[0].toUpperCase();
            Object o = scriptManager.getCommandHandlers().get(command);
            if (o != null && o instanceof CommandHandler) {
                return (CommandHandler) o;
            }

            command = command.toLowerCase();
            if (command.equals("procedure") || command.equals("run") || command.equals("include")) {
                return new DummyCommandHandler(command);
            }

        }
        return null;
    }

    private class DummyCommandHandler extends AbstractCommandHandler {

        private String cmdName;

        DummyCommandHandler(String cmdName) {
            this.cmdName = cmdName;
        }

        public void validate(List params, Map values, Map variableContainer, ScriptingContext repository) throws SyntaxErrorException {
        }

        public String[] getCommandNames() {
            return new String[]{cmdName};
        }

        public int execute(List params, Map values, ScriptingContext repository) throws SyntaxErrorException {
            return 0;
        }

        public String getCode() {
            return cmdName;
        }

        public String getDisplayName() {
            return "Dummy";
        }

        public String getDescription() {
            return null;
        }

        public String getUniqueId() {
            return "VNCRobot_native_dummy_cmd_handler";
        }

        public void checkDependencies(PluginManager manager) throws DependencyMissingException {
        }
    }
}
